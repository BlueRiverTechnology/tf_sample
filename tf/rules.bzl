load(":providers.bzl", "PluginInfo")

# Extract and copy terraform providers to the particularly structured plugin cache folder.
def _tf_provider_impl(ctx):
    plugins = ctx.toolchains["//tf:toolchain_type"].plugins
    plugin_name = ctx.attr.plugin
    matched = []
    for p in plugins:
        plugin_info = p[PluginInfo]
        plugin_file = plugin_info.plugin_file
        if plugin_file.basename == plugin_name:
            matched.append(p)
    if len(matched) == 0:
        fail("Could not find terraform plugin %s." % plugin_name)
    if len(matched) > 1:
        print(matched)
        fail("Multiple plugins with name %s found." % plugin_name)
    return [
        p[PluginInfo],
        p[DefaultInfo],
    ]

tf_provider = rule(
    implementation = _tf_provider_impl,
    attrs = {
        "plugin": attr.string(
            mandatory = True,
        ),
    },
    toolchains = ["//tf:toolchain_type"],
)

TerraformModuleInfo = provider(
    "Info needed to run terraform actions: init, plan, apply",
    fields = {
        "module_marker": "File to mark module in the build tree",
        "output_marker": "File to mark terraform output folder",
    },
)

def _tf_module_impl(ctx):
    out_marker = ctx.actions.declare_file(ctx.label.name + ".tf_module")
    ctx.actions.symlink(
        output = out_marker,
        target_file = ctx.file.marker,
    )

    Continue:
    1. bring all plugins to build tree
    2. filter plugins by name

    return [
        TerraformModuleInfo(
            module_marker = ctx.file.marker,
            output_marker = out_marker,
        ),
        DefaultInfo(
            files = depset(ctx.files.srcs + ctx.files.providers),
        ),
    ]

tf_module = rule(
    implementation = _tf_module_impl,
    attrs = {
        "marker": attr.label(
            allow_single_file = True,
            mandatory = True,
        ),
        "srcs": attr.label_list(
            allow_files = [".tf"],
            mandatory = False,
        ),
        "plugin_names": attr.string_list(),
    },
)

# Generate terraform lock file in workspace.
def _tf_init_impl(ctx):
    # Let's collects module context.
    module_info = ctx.attr.module[TerraformModuleInfo]
    module_srcs = ctx.attr.module[DefaultInfo].files  # TODO Make sure to get transient too

    terraform = ctx.toolchains["//tf:toolchain_type"].executable

    out_file = ctx.actions.declare_file(ctx.label.name + ".bash")
    content = """#!/bin/bash
set -eu
{terraform} -chdir={terraform_run_folder} init \
    -plugin-dir=. -input=false -no-color
rm -f $BUILD_WORKSPACE_DIRECTORY/{terraform_run_folder}/.terraform.lock.hcl
cp {terraform_run_folder}/.terraform.lock.hcl $BUILD_WORKSPACE_DIRECTORY/{terraform_run_folder}
chmod 644 $BUILD_WORKSPACE_DIRECTORY/{terraform_run_folder}/.terraform.lock.hcl
""".format(
        terraform = terraform.path,
        terraform_run_folder = module_info.module_marker.dirname,
        output_folder = module_info.output_marker.dirname,
    )
    ctx.actions.write(
        output = out_file,
        content = content,
        is_executable = True,
    )
    runfiles = ctx.runfiles(
        files = [terraform] + module_srcs.to_list(),
    )
    return [DefaultInfo(
        files = depset([out_file]),
        executable = out_file,
        runfiles = runfiles,
    )]

tf_init = rule(
    implementation = _tf_init_impl,
    attrs = {
        "module": attr.label(
            providers = [TerraformModuleInfo],
            mandatory = True,
        ),
    },
    executable = True,
    toolchains = ["//tf:toolchain_type"],
)

# TODO A couple more options to try:
# export TF_PLUGIN_CACHE_DIR=
# -lock=false

PlanInfo = provider(
    "Info needed to run terraform apply",
    fields = {
        "plan_file": "File generated by terraform plan",
    },
)

def _tf_plan_impl(ctx):
    plan = ctx.outputs.plan
    terraform_dir = ctx.outputs.terraform_dir
    outputs = [ctx.outputs.plan, terraform_dir]

    terraform = ctx.toolchains["//tf:toolchain_type"].executable

    command = """
# export TF_LOG=debug
set -eu
{terraform} -chdir={terraform_run_folder} init \
 -plugin-dir=$(pwd)/{output_folder} \
 -input=false -no-color
{terraform} -chdir={terraform_run_folder} plan \
 -out=tfplan \
 -input=false
rm -rf $1
cp {terraform_run_folder}/tfplan $1
rm -rf $2
cp -rL {terraform_run_folder}/.terraform $2
""".format(
        terraform = terraform.path,
        terraform_run_folder = ctx.file.lock.dirname,
        output_folder = plan.dirname,
    )
    transitive = depset(ctx.files.providers)
    input = depset(
        [ctx.file.provider, ctx.file.lock],
        transitive = [transitive, depset(ctx.files.srcs)],
    )
    ctx.actions.run_shell(
        mnemonic = "TerraformInit",
        inputs = input,
        tools = ctx.files._terraform,
        command = command,
        arguments = [plan.path, terraform_dir.path],
        outputs = outputs,
    )

    return [
        PlanInfo(
            plan_file = plan,
        ),
        DefaultInfo(
            files = depset(
                outputs,
                transitive = [depset(ctx.files.srcs + [ctx.file.provider, ctx.file.lock])],
            ),
        ),
    ]

tf_plan = rule(
    implementation = _tf_plan_impl,
    attrs = {
        "lock": attr.label(
            default = ".terraform.lock.hcl",
            allow_single_file = True,
            mandatory = True,
        ),
        "provider": attr.label(
            default = "provider.tf",
            allow_single_file = True,
            mandatory = True,
        ),
        "srcs": attr.label_list(
            allow_files = [".tf"],
            mandatory = False,
        ),
        "providers": attr.label_list(
            allow_files = True,
            mandatory = False,
        ),
    },
    outputs = {
        "plan": "tfplan",
        "terraform_dir": ".terraform",
    },
    toolchains = ["//tf:toolchain_type"],
)

def _tf_apply_impl(ctx):
    out_file = ctx.actions.declare_file(ctx.label.name + ".bash")
    plan_info_dep = ctx.attr.plan[PlanInfo]
    plan_default_dep = ctx.attr.plan[DefaultInfo]

    terraform = ctx.toolchains["//tf:toolchain_type"].executable

    content = """
#!/bin/bash
set -eu
{terraform} -chdir={terraform_run_folder} apply \
 -input=false \
 tfplan
""".format(
        terraform = terraform.path,
        terraform_run_folder = ctx.label.package,
    )
    ctx.actions.write(
        output = out_file,
        content = content,
        is_executable = True,
    )
    runfiles = ctx.runfiles(
        files = ctx.files._terraform + plan_default_dep.files.to_list(),
    )
    return [DefaultInfo(
        files = depset([out_file]),
        executable = out_file,
        runfiles = runfiles,
    )]

tf_apply = rule(
    implementation = _tf_apply_impl,
    attrs = {
        "plan": attr.label(
            mandatory = True,
            # TODO it should have constraint on PlanInfo
        ),
    },
    toolchains = ["//tf:toolchain_type"],
    executable = True,
)
